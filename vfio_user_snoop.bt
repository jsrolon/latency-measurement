#!/usr/bin/env bpftrace
/*
 * undump	Trace unix domain socket package receive.
 *		For Linux, uses bpftrace and eBPF.
 *
 * Also a basic example of bpftrace.
 *
 * This is a bpftrace version of the bcc examples/tracing of the same name.
 *
 * USAGE: undump.bt
 *
 * Copyright 2022 CESTC, Inc.
 * Licensed under the Apache License, Version 2.0 (the "License")
 *
 * 22-May-2022	Rong Tao	Created this.
 */
#ifndef BPFTRACE_HAVE_BTF
#include <linux/socket.h>
#endif

struct vfio_user_header {
    uint16_t    msg_id;
    uint16_t    cmd;
    uint32_t    msg_size;
	uint32_t	flags;
	uint32_t	error;
};

struct vfio_user_packet_irq {
    struct vfio_user_header header;
	uint32_t				argsz;
	uint32_t				flags;
	uint32_t				index;
	uint32_t				start;
	uint32_t				count;
	void*					data;
};

struct vfio_user_packet_rw {
	struct vfio_user_header header;
	uint64_t				offset;
	uint32_t				region;
	uint32_t				count;
	void* 					data;
};

BEGIN
{
	@vfio_user_msg_ids[1] = "version";
	@vfio_user_msg_ids[2] = "dma_map";
	@vfio_user_msg_ids[3] = "dma_unmap";
	@vfio_user_msg_ids[4] = "info";
	@vfio_user_msg_ids[5] = "region_info";
	@vfio_user_msg_ids[6] = "region_io_fds";
	@vfio_user_msg_ids[7] = "irq_info";
	@vfio_user_msg_ids[8] = "irq";
	@vfio_user_msg_ids[9] = "r_read";
	@vfio_user_msg_ids[10] = "r_write";
	@vfio_user_msg_ids[11] = "d_read";
	@vfio_user_msg_ids[12] = "d_write";
	@vfio_user_msg_ids[13] = "reset";
	@vfio_user_msg_ids[14] = "dirty_pages";

	@count[8] = 0; // command counter
	
	@qemu_pid = $1;
	@vfio_user_socket_fd = $2;
	printf("%-2s %-6s %-14s %-4s %-4s %-4s %-8s\n", "UX", "MSGID", "CMD", "SZ", "FLG", "ERR", "DATA");
}

// field:int __syscall_nr; offset:8;       size:4; signed:1;
// field:int fd;   offset:16;      size:8; signed:0;
// field:struct user_msghdr * msg; offset:24;      size:8; signed:0;
// field:unsigned int flags;       offset:32;      size:8; signed:0;
tracepoint:syscalls:sys_enter_sendmsg
/ pid == @qemu_pid /
{
	$fd = args->fd;
	if ($fd == @vfio_user_socket_fd) {
		$vfio_user_msg_iov = ((struct iovec *)args->msg->msg_iov)[0];
		$vfio_user_header = (struct vfio_user_header *)$vfio_user_msg_iov.iov_base;
		
		$cmd = $vfio_user_header->cmd;
		if($cmd > 0) {
			printf("%-2s %-6d %-14s %-4d %-4d %-4d ",
			"->",
			$vfio_user_header->msg_id, 
			@vfio_user_msg_ids[$cmd],
			$vfio_user_header->msg_size, 
			$vfio_user_header->flags,
			$vfio_user_header->error);

			if($cmd == 8) { // irq sets
				$packet_irq = (struct vfio_user_packet_irq *)$vfio_user_msg_iov.iov_base;
				printf("ASZ=%-12d FLAGS=%-4d IDX=%-4d START=%-4d COUNT=%-4d DATA=%r", 
				$packet_irq->argsz, 
				$packet_irq->flags, 
				$packet_irq->index,
				$packet_irq->start,
				$packet_irq->count,
				buf($packet_irq->data, $packet_irq->count));
			}
			
			if($cmd == 9 || $cmd == 10) { // reads and writes
				$packet_rw = (struct vfio_user_packet_rw *)$vfio_user_msg_iov.iov_base;
				printf("OFF=%-12d REG=%-4d COUNT=%-4d DATA=%r", $packet_rw->offset, $packet_rw->region, $packet_rw->count, buf($packet_rw->data, $packet_rw->count));
			}

			printf("\n");
		}
	}
}

// field:int __syscall_nr; offset:8;       size:4; signed:1;
// field:int fd;   offset:16;      size:8; signed:0;
// field:struct user_msghdr * msg; offset:24;      size:8; signed:0;
// field:unsigned int flags;       offset:32;      size:8; signed:0;
tracepoint:syscalls:sys_enter_recvmsg
/ pid == @qemu_pid /
{
	$fd = args->fd;
	if ($fd == @vfio_user_socket_fd) {
		$vfio_user_msg_iov = ((struct iovec *)args->msg->msg_iov)[0];
		$vfio_user_header = (struct vfio_user_header *)$vfio_user_msg_iov.iov_base;
		
		$cmd = $vfio_user_header->cmd;
		if($cmd > 0) {
			@count[$cmd]++;

			printf("%-2s %-6d %-14s %-4d %-4d %-4d ",
			"<-",
			$vfio_user_header->msg_id, 
			@vfio_user_msg_ids[$cmd],
			$vfio_user_header->msg_size, 
			$vfio_user_header->flags,
			$vfio_user_header->error);

			if($cmd == 8) { // irq sets
				$packet_irq = (struct vfio_user_packet_irq *)$vfio_user_msg_iov.iov_base;
				printf("ASZ=%-12d FLAGS=%-4d IDX=%-4d START=%-4d COUNT=%-4d DATA=%r", 
				$packet_irq->argsz, 
				$packet_irq->flags, 
				$packet_irq->index,
				$packet_irq->start,
				$packet_irq->count,
				buf($packet_irq->data, $packet_irq->count));
			}
			
			if($cmd == 9 || $cmd == 10) { // reads and writes
				$packet_rw = (struct vfio_user_packet_rw *)$vfio_user_msg_iov.iov_base;
				printf("OFF=%-12d REG=%-4d COUNT=%-4d DATA=%r", $packet_rw->offset, $packet_rw->region, $packet_rw->count, buf($packet_rw->data, $packet_rw->count));
			}

			printf("\n");
		}
	}
}

END
{
}
